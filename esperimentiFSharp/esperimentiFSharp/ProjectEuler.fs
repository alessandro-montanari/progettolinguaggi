// Problem 1 ----------------------------------
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.

let naturals = seq { 0 .. 999 }

// Alternativa 1
let mutipleOfThree n =
    n % 3 = 0
let mutipleOfFive n =
    n % 5 = 0
let mutipleOfThreeOrFive n =
    mutipleOfThree n || mutipleOfFive n
let multiplesOfThreeOrFive sequence =
    sequence |> Seq.filter mutipleOfThreeOrFive
let sumOfMultiplesOF3And5 sequence =
    sequence |> multiplesOfThreeOrFive |> Seq.sum
let sum4 = seq { 0 .. 999 } |> sumOfMultiplesOF3And5

// Alternativa 2
let sum = seq { 0 .. 999 } |> Seq.filter (fun el -> el % 3 = 0 || el % 5 = 0 ) |> Seq.sum

// Alternativa 3
let sum2 = seq { for i in 0 .. 999 do if i % 3 = 0 || i % 5 = 0 then yield i } |> Seq.sum

// Alternativa 4
let rec sumOfMultiplesOF3And5Rec list =
    match list with
    | [] -> 0
    | h :: t when h % 3 = 0 || h % 5 = 0 -> h + sumOfMultiplesOF3And5Rec t
    | h :: t -> sumOfMultiplesOF3And5Rec t
let sum3 = sumOfMultiplesOF3And5Rec [ 0 .. 999 ]

// Per capire l'ondemand delle sequences
[| 0I .. 99999999I |] |> Array.filter (fun el -> el % 3I = 0I || el % 5I = 0I ) |> Array.sum        // Arriva in breve a 2 GB di memoria senza calcolare il risultato (System.OutOfMemoryException: Out of memory)
seq { 0I .. 99999999I } |> Seq.filter (fun el -> el % 3I = 0I || el % 5I = 0I ) |> Seq.sum          // Con 72 MB di memoria arriva al risultato


// Problem 2 ----------------------------------
// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

let rec fibonacci n =
    match n with
    | 0 -> 0
    | n when n <= 2 -> 1
    | n -> fibonacci(n-1) + fibonacci(n-2)

List.init 34 fibonacci |> List.filter (fun el -> el % 2 = 0 ) |> List.sum


// Problem 3 ----------------------------------
// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?

// Un metodo per verificare se un numero n è primo si definisce test di primalità. Un metodo che discende direttamente dalla definizione 
// è controllare che non sia diviso da nessun numero minore di n o, in modo più efficiente, da nessun primo minore di n. Ad esempio, per 
// provare che 11 è primo, basta osservare che non è diviso da 2, 3, 5 e 7 (che sono i primi minori di 11).

let rec checkDivisibility number sequence =
    match Seq.length sequence with
    | 0 -> false
    | n -> if number % Seq.head sequence = 0 then
                true
           else
                checkDivisibility number (Seq.skip 1 sequence)
        
checkDivisibility 12 (seq [ 2; 3; 5; 7; 11 ])

let rec innerLoop (sequence : seq<int>) (primes : seq<int>) =
    match Seq.length sequence with
    | 0 -> primes
    | n -> if (checkDivisibility (Seq.head sequence) primes) = false then
               let primes2 = Seq.append primes (seq [head])
               primes2

//let primeGenerator n =
//    let sequenceNoOdd = seq { 3 .. n } |> Seq.filter (fun el -> el % 2 <> 0)
//    let primes = Seq.append (seq [2]) (seq [])
//    innerLoop sequenceNoOdd primes
    
    
    
    
    
    
    
    