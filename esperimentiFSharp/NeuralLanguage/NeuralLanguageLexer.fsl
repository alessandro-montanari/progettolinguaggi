{
open System
open Lexing

// Apro il modulo del parser per avere accesso ai token definiti li'
open NeuralLanguageParser

let keywords =
	[
		"PREPROCESSING", PREPROC;
		"TRAINIG", TRAINING;
		"VALIDATION", VALIDATION;
		"WHIT_PLOT", PLOT;
	] |> Map.ofList

let mathOps =
	[
		"+", PLUS;
		"-", MINUS;
		"*", TIMES;
		"/", FRAC;
		"^", POW;
	] |> Map.ofList

let logicOps =
	[
		"&&", AND;
		"||", OR;
		"!", NOT;
		"true", TRUE;
		"false", FALSE;
	] |> Map.ofList

let functions =
	[
		"sin", SIN;
		"cos", COS;
		"tan", TAN;
		"atan", ATAN;
		"log", LOG;
		"ln", LN;
		"floor", FLOOR;
		"ceil", CEIL;
		"sqrt", SQRT; 
	] |> Map.ofList

let relOps =
	[
		"<", LT;
		"<=", LTE;
		">", GT;
		">=", GTE;
		"==", EQ;
		"!=", NOTEQ;
	] |> Map.ofList


}

let char		= ['a'-'z' 'A'-'Z']
let digit		= ['0'-'9']
let number		= '-'?digit '.' digit+
let whitespace	= [' ' '\t']
let newline		= "\n\r" | '\n' | '\r'
let identifier	= char(char|digit|['-' '_'])*
let attIdentifier = "ATT"(digit)+
let mathOp = '+' | '-' | '*' | '/' | '^'
let logicOp = "&&" | "||" | '!' | "true" | "false"
let function = "sin" | "cos" | "tan" | "atan" | "log" | "ln" | "floor" | "ceil" | "sqrt" 
let relOp = '<' | "<=" | '>' | ">=" | "==" | "!="

// rules
rule tokenize = parse
	| whitespace	{ tokenize lexbuf }
	| newline		{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf; }
	| number		{ NUMBER(Converter.ToDouble(lexeme lexbuf)) }
 	| identifier	{ match keywords.TryFind(lexeme lexbuf) with
						| Some(token)	-> token
						| None			-> ID(lexeme lexbuf) }
	| attIdentifier	{ ATTID(lexeme lexbuf) }
	| mathOp		{ mathOps.[lexeme lexbuf] }
	| logicOp		{ logicOps.[lexeme lexbuf] }
	| function		{ functions.[lexeme lexbuf] }
	| relOp			{ relOps.[lexeme lexbuf] }
	| ','			{ COMMA }
	| '('			{ LP }
	| ')'			{ RP }
	| '{'			{ LCB }
	| '}'			{ RCB }
	| '['			{ LB }
	| ']'			{ RB }
	| ':'			{ COLON }
	| ".."			{ DOTS }
	| eof			{ EOF }

