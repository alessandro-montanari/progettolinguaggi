%{
open System
open AST

let cultureInfo = System.Globalization.CultureInfo.CreateSpecificCulture("en-us")
%}

// Simboli terminali
%token <string> ID
%token <string> ATTID
%token <string> INSTID			
%token <string> PATH
%token <double> NUMBER
%token PLUS MINUS TIMES FRAC POW
%token AND OR NOT TRUE FALSE
%token LT LTE GT GTE EQ NOTEQ
%token SIN COS TAN ATAN LOG LN FLOOR CEIL SQRT
%token MEAN SD MIN MAX SUM SUMSQUARED
%token LP RP LCB RCB LB RB COMMA NEWLINE COLON DOTS SEMICOLON
%token PREPROC TRAINING VALIDATION PLOT ATTKEY INSTKEY
%token EOF

// Associatività operatori e priorità (priorità minore prima)

// Forse bisogna mettere anche le parentesi
%left AND OR
%left LT LTE GT GTE EQ NOTEQ			// NONASSOC -  Questi operatori se compaiono più di una volta si ha errore "1 > 2 > 3 -> Errore"
%left PLUS MINUS
%left TIMES FRAC 
%left UMINUS							// Non esiste veramente, serve solo per la precedenza
%right POW
%nonassoc NOT

// Scopo della grammatica
%start start

// Tipo di uscita in caso di parsing corretto
//%type <AST.Network> start

%type <AST.Parameter list * (AST.Filter list * AST.Filter list)> start

%%

// Produzioni

//start:	directives
//		preprocessing
//		network
//		training
//		validation
//		EOF				{ { Directives = $1; Preprocessing = $2; NetworkDefinition = $3; Training = $4; Validation = $5;} }

start : directives
		preprocessing
		EOF				{ ($1, $2) }

parameter : ID COLON parameterValue		{ Parameter ($1, $3) }

parameterValue :
	| attributeList					{ AttList (true, $1) }
	| NOT attributeList				{ AttList (false, $2) }
	| numberList					{ NumList (true, $1) }
	| NOT numberList				{ NumList (false, $2) }
	| instList						{ InstList (true, $1) }
	| NOT instList					{ InstList (false, $2) }
	| expression					{ Exp $1 }

attributeList : LB attributeInnerList RB						{ $2 }

attributeInnerList :
	| attributeElement								{ [$1] }
	| attributeElement COMMA attributeInnerList		{ $1 :: $3 }

attributeElement :
	| ATTID DOTS ATTID					{ AttributeSequence (Convert.ToInt32($1, cultureInfo), Convert.ToInt32($3, cultureInfo)) }	
	| ID								{ Id $1 }
	| ATTID								{ AttId (Convert.ToInt32($1, cultureInfo)) }

numberList :
	| LB numberInnerList RB						{ $2 }
	
numberInnerList :
	| numberElement								{ [$1] }
	| numberElement COMMA numberInnerList 		{ $1 :: $3 }

numberElement :
	| number DOTS number				{ NumberSequence (Convert.ToDouble($1, cultureInfo), Convert.ToDouble($3, cultureInfo)) }	
	| number							{ Num (Convert.ToDouble($1, cultureInfo)) }

instList :
	| LB instInnerList RB				{ $2 }
	
instInnerList :
	| instElement						{ [$1] }
	| instElement COMMA instInnerList 	{ $1 :: $3 }

instElement :
	| INSTID DOTS INSTID					{ InstanceSequence (Convert.ToInt32($1, cultureInfo), Convert.ToInt32($3, cultureInfo)) }	
	| INSTID								{ InstId (Convert.ToInt32($1, cultureInfo)) }

directives :
	|									{ [] }
	| parameter							{ [$1] }
	| parameter SEMICOLON directives	{ $1 :: $3 }


// Mettendo l'associatività e la priorità sopra posso definire la grammatica delle espressioni in modo molto più compatto
expression :
	| NOT expression					{ Not $2 }
	| MINUS LP expression RP 			{ Neg $3 }			// Forse non serve
	| expression POW expression			{ Pow ($1, $3) }
	| expression TIMES expression		{ Prod ($1, $3) }
	| expression FRAC expression		{ Frac ($1, $3) }
	| expression PLUS expression		{ Add ($1, $3) }
	| expression MINUS expression		{ Sub ($1, $3) }
	| expression LT expression			{ Rel ($1, Lt, $3) }
	| expression LTE expression			{ Rel ($1, Lte, $3) }
	| expression GT expression			{ Rel ($1, Gt, $3) }
	| expression GTE expression			{ Rel ($1, Gte, $3) }
	| expression EQ expression			{ Rel ($1, Eq, $3) }
	| expression NOTEQ expression		{ Rel ($1, NotEq, $3) }
	| expression AND expression			{ And ($1, $3) }
	| expression OR expression			{ Or ($1, $3) }
	| SIN LP expression RP				{ Sin $3 }
	| COS LP expression RP				{ Cos $3 }
	| TAN LP expression RP				{ Tan $3 }
	| ATAN LP expression RP				{ Atan $3 }
	| LOG LP expression RP				{ Log $3 }
	| LN LP expression RP				{ Ln $3 }
	| FLOOR LP expression RP			{ Floor $3 }
	| CEIL LP expression RP				{ Ceil $3 }
	| SQRT LP expression RP				{ Sqrt $3 }
	| LP expression RP					{ $2 }
	| MEAN LP statElement RP			{ Mean $3 }
	| SD LP statElement RP				{ Sd $3 }
	| MIN LP statElement RP				{ Min $3 }
	| MAX LP statElement RP				{ Max $3 }
	| SUM LP statElement RP				{ Sum $3 }
	| SUMSQUARED LP statElement RP		{ SumSquared $3 }
	| ID								{ ExpId $1 }
	| ATTID								{ ExpAttId (Convert.ToInt32($1, cultureInfo)) }
	| TRUE								{ True }
	| FALSE								{ False }
	| number							{ ExpNum $1 }

number:
    | NUMBER                           { Convert.ToDouble($1, cultureInfo) }
    | MINUS NUMBER %prec UMINUS		   { Convert.ToDouble(-$2, cultureInfo) }		// La precedenza di questa REGOLA è pari alla precedenza di UMINUS

statElement :														
	| ID							{ $1 }
	| ATTID							{ $1 }

parameterList :
	|									{ [] }
	| parameter							{ [$1] }
	| parameter COMMA parameterList		{ $1 :: $3 }

filter : ID LP parameterList RP		{ Filter ($1, $3) }

filterList : 
	|								{ [] }
	| filter						{ [$1] }
	| filter SEMICOLON filterList	{ $1 :: $3 }

attributeFilters : ATTKEY LCB filterList RCB	{ $3 }
instanceFilters : INSTKEY LCB filterList RCB	{ $3 }

preprocessing : PREPROC
				LCB
				attributeFilters								// filtri per gli attributi SEMPRE prima di quelli per le istanze
				instanceFilters
				RCB					{ ($3, $4) }

network : ID	{}

training : TRAINING ID	{}

validation : VALIDATION {}