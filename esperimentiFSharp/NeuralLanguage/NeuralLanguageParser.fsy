%{
open System
open AST

let cultureInfo = System.Globalization.CultureInfo.CreateSpecificCulture("en-us")

// Per errori vedi reportParseErrorAt nella grammatica di F#


%}

// Simboli terminali
%token <string> STRING
%token <int> ATTINDEX
%token <int> INSTINDEX		
%token <string> QUOTEDSTRING	

%token LP RP LCB RCB LB RB COMMA NEWLINE COLON DOTS SEMICOLON
%token PREPROC TRAININGKEY VALIDATIONKEY PLOT ATTKEY INSTKEY TRAINSETKEY TESTSETKEY NETWORKKEY CLASSKEY LOADTRAIN LOADNET ASPECTKEY

%token <System.Double> DOUBLE
%token <bool> BOOLEAN
%token <string> FUNCTION
%token <string> AGGFUNCTION
%token PLUS MINUS ASTER	SLASH POW
%token AND OR NOT TRUE FALSE
%token LT LTE GT GTE EQ NOTEQ
%token SUMOFPRODUCTS

%token EOF

%nonassoc STRING

// Scopo della grammatica
%start start

// Tipo di uscita in caso di parsing corretto
%type <AST.Network> start

%%

// Produzioni

start:	directives
		trainingSet
		classAttribute
		preprocessing
		network
		training
		validation
		EOF				{ { Directives = $1; TrainingSet = $2; ClassAttribute = $3; Preprocessing = $4; NetworkDefinition = $5; Training = $6; Validation = $7;} }

directives :
	| parameterListOpt						{ $1 }

trainingSet: TRAINSETKEY COLON QUOTEDSTRING 		{ $3 }

classAttribute : CLASSKEY COLON QUOTEDSTRING 		{ $3 }

preprocessing : PREPROC
				LCB
				attributeFilters								// filtri per gli attributi SEMPRE prima di quelli per le istanze
				instanceFilters
				RCB					{ ($3, $4) }

network : NETWORKKEY STRING							
          LCB
		  parameterListOpt					
		  aspectListOpt
		  RCB 						{ ($2, $4, $5) }

training :	TRAININGKEY STRING
			LCB
			parameterListOpt					
		    aspectListOpt
		    RCB 					{ ($2, $4, $5) }

validation :
	|							{ ([], []) }	
	|	VALIDATIONKEY
		LCB
		parameterListOpt					
		aspectListOpt
		RCB 						{ ($3, $4) }


parameter : STRING COLON parameterValue		{ Parameter ($1, $3) }

parameterValue :
	| BOr							{ Exp $1 }
	| QUOTEDSTRING					{ String $1 }
	| attributeList					{ AttList (true, $1) }
	| NOT attributeList				{ AttList (false, $2) }
	| numberList					{ NumList (true, $1) }
	| NOT numberList				{ NumList (false, $2) }
	| instList						{ InstList (true, $1) }
	| NOT instList					{ InstList (false, $2) }

attributeList : LB attributeInnerList RB	{ $2 }

attributeInnerList :
	| attributeElement 								{ [$1] }
	| attributeElement COMMA attributeInnerList		{ $1 :: $3 }

attributeElement :
	| ATTINDEX DOTS ATTINDEX			{ AttSequence (Convert.ToInt32($1, cultureInfo), Convert.ToInt32($3, cultureInfo)) }	
	| QUOTEDSTRING						{ AttName $1 }
	| ATTINDEX							{ AttIndex (Convert.ToInt32($1, cultureInfo)) }

numberList :
	| LB numberInnerList RB						{ $2 }
	
numberInnerList :
	| numberElement								{ [$1] }
	| numberElement COMMA numberInnerList 		{ $1 :: $3 }

numberElement :
	| BOr DOTS BOr				{ NumberSequence ($1, $3) }	
	| BOr						{ NumberListElement.Exp $1 }

instList :
	| LB instInnerList RB				{ $2 }
	
instInnerList :
	| instElement						{ [$1] }
	| instElement COMMA instInnerList 	{ $1 :: $3 }

instElement :
	| INSTINDEX DOTS INSTINDEX          { InstSequence (Convert.ToInt32($1, cultureInfo), Convert.ToInt32($3, cultureInfo)) }	
	| INSTINDEX							{ InstIndex (Convert.ToInt32($1, cultureInfo)) }

parameterList :
	| parameter							{ [$1] }
	| parameter COMMA parameterList		{ $1 :: $3 }

parameterListOpt :
	|									{ [] }
	| parameterList	%prec STRING					{ $1 }

filter : 
	| STRING LP parameterListOpt RP		{ Filter ($1, $3) }

filterList :
	|								{ [] } 
	| filter						{ [$1] }
	| filter COMMA filterList		{ $1 :: $3 }

attributeFilters : ATTKEY LCB filterList RCB	{ $3 }
instanceFilters : INSTKEY LCB filterList RCB	{ $3 }

aspect : ASPECTKEY STRING					
		 LCB
		 parameterList
		 RCB						{ Aspect ($2, $4) }

aspectList :
	| aspect					{ [$1] }					// Se qui metto la lista vuota ho un errore reduce/reduce  (DA RIVEDERE)
	| aspect aspectList			{ $1 :: $2 }

aspectListOpt :
	|				{ [] }
	| aspectList	{ $1 }



// ============================================================================================
// ==========================ESPRESSIONI=======================================================
// ============================================================================================

BOr:
	| BAnd					{ $1 }
	| BOr OR BAnd			{ Or($1, $3) }

BAnd:
	| CondExpr				{ $1 }
	| BAnd AND CondExpr		{ And($1, $3) }

CondExpr:
	| Additive						{ $1 }
	| CondExpr LT Additive			{ Lt($1, $3) }
	| CondExpr LTE Additive			{ Lte($1, $3) }
	| CondExpr GT Additive			{ Gt($1, $3) }
	| CondExpr GTE Additive			{ Gte($1, $3) }
	| CondExpr EQ Additive			{ Eq($1, $3) }
	| CondExpr NOTEQ Additive		{ NotEq($1, $3) }
	
Additive: 
    | Additive PLUS  Multiplicative		{ Plus($1, $3)  }
    | Additive MINUS Multiplicative		{ Minus($1, $3) }
	| Additive POW Multiplicative		{ Pow($1, $3) }
    | Multiplicative					{ $1 }

Multiplicative:
    | Multiplicative ASTER Unary		{ Times($1, $3)  }
    | Multiplicative SLASH Unary		{ Divide($1, $3) }
    | Unary								{ $1 }

Unary:
    | Value			{ $1 }
    | MINUS Value	{ Negative($2) }
	| NOT Value		{ Not($2) }
    
Value:
	| BOOLEAN											{ Value(Boolean($1))}
    | DOUBLE											{ Value(Double($1))  }
	| STRING											{ Value(Id($1)) }
    | LP BOr RP											{ $2 }
	| FUNCTION LP BOr RP								{ Value(Function($1, $3)) }
	| AGGFUNCTION LP ExprList RP						{ Value(AggregateFunction($1, $3)) }
	| SUMOFPRODUCTS LP ExprList SEMICOLON ExprList RP	{ Value(SumOfProducts($3, $5)) }

ExprList:
	| BOr						{ [$1] }
	| LB ExprInnerList RB		{ $2 }

ExprInnerList:
	| BOr						{ [$1] }
	| BOr COMMA ExprInnerList 	{ $1 :: $3 }

