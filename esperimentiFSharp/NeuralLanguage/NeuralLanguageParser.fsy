%{
open System
open AST

let cultureInfo = System.Globalization.CultureInfo.CreateSpecificCulture("en-us")

// Per errori vedi reportParseErrorAt nella grammatica di F#


%}

// Simboli terminali
%token <string> ID
%token <string> ATTID		// Devo proprio distingure questi due id da degli identificatori classici???
%token <string> INSTID			
%token <string> PATH
%token <double> NUMBER

%token LP RP LCB RCB LB RB COMMA NEWLINE COLON DOTS SEMICOLON
%token PREPROC TRAININGKEY VALIDATIONKEY PLOT ATTKEY INSTKEY TRAINSETKEY PLOTKEY TESTSETKEY
%token EOF

// Scopo della grammatica
%start start

// Tipo di uscita in caso di parsing corretto
%type <AST.Network> start

%%

// Produzioni

start:	directives
		preprocessing
		network
		training
		validation
		EOF				{ { Directives = $1; Preprocessing = $2; NetworkDefinition = $3; Training = $4; Validation = $5;} }

parameter : ID COLON parameterValue		{ Parameter ($1, $3) }

parameterValue :
	| attributeList					{ AttList (true, $1) }
	| NOT attributeList				{ AttList (false, $2) }
	| numberList					{ NumList (true, $1) }
	| NOT numberList				{ NumList (false, $2) }
	| instList						{ InstList (true, $1) }
	| NOT instList					{ InstList (false, $2) }
	| expression					{ Exp $1 }

attributeList : LB attributeInnerList RB						{ $2 }

attributeInnerList :
	| attributeElement								{ [$1] }
	| attributeElement COMMA attributeInnerList		{ $1 :: $3 }

attributeElement :
	| ATTID DOTS ATTID					{ AttributeSequence (Convert.ToInt32($1, cultureInfo), Convert.ToInt32($3, cultureInfo)) }	
	| ID								{ Id $1 }
	| ATTID								{ AttId (Convert.ToInt32($1, cultureInfo)) }

numberList :
	| LB numberInnerList RB						{ $2 }
	
numberInnerList :
	| numberElement								{ [$1] }
	| numberElement COMMA numberInnerList 		{ $1 :: $3 }

numberElement :
	| number DOTS number				{ NumberSequence (Convert.ToDouble($1, cultureInfo), Convert.ToDouble($3, cultureInfo)) }	
	| number							{ Num (Convert.ToDouble($1, cultureInfo)) }

instList :
	| LB instInnerList RB				{ $2 }
	
instInnerList :
	| instElement						{ [$1] }
	| instElement COMMA instInnerList 	{ $1 :: $3 }

instElement :
	| INSTID DOTS INSTID					{ InstanceSequence (Convert.ToInt32($1, cultureInfo), Convert.ToInt32($3, cultureInfo)) }	
	| INSTID								{ InstId (Convert.ToInt32($1, cultureInfo)) }

directives :
	|									{ [] }
	| parameterList						{ $1 }

number:
    | NUMBER                           { Convert.ToDouble($1, cultureInfo) }
    | MINUS NUMBER %prec UMINUS		   { Convert.ToDouble(-$2, cultureInfo) }		// La precedenza di questa REGOLA è pari alla precedenza di UMINUS

statElement :														
	| ID							{ $1 }
	| ATTID							{ $1 }

parameterList :
	| parameter							{ [$1] }
	| parameter COMMA parameterList		{ $1 :: $3 }

parameterListOpt :
	|					{ [] }
	| parameterList		{ $1 }

filter : 
	| ID LP parameterList RP		{ Filter ($1, $3) }
	| ID LP RP						{ Filter ($1, []) }

filterList :
	|								{ [] } 
	| filter						{ [$1] }
	| filter COMMA filterList		{ $1 :: $3 }

attributeFilters : ATTKEY LCB filterList RCB	{ $3 }
instanceFilters : INSTKEY LCB filterList RCB	{ $3 }

preprocessing : PREPROC
				LCB
				TRAINSETKEY COLON ID
				attributeFilters								// filtri per gli attributi SEMPRE prima di quelli per le istanze
				instanceFilters
				RCB					{ ($5, $6, $7) }

aspect : ID					
		 LCB
		 parameterList
		 RCB						{ Aspect ($1, $3) }

aspectList :
	| aspect					{ [$1] }					// Se qui metto la lista vuota ho un errore reduce/reduce  (DA RIVEDERE)
	| aspect aspectList			{ $1 :: $2 }

aspectListOpt :
	|				{ [] }
	| aspectList	{ $1 }

plot :
	|			{ false }
	| PLOTKEY	{ true }

network : 
	|	ID plot							// Con il plot opzionale vuol dire che qui la stringa si può accorciare? E' un problema??
		LCB
		parameterList					// Qui non posso usare parameterListOpt (DA RIVEDERE)
		aspectListOpt
		RCB 				{ ($1, $2, $4, $5) }
	|	ID plot							
		LCB					
		aspectListOpt
		RCB 				{ ($1, $2, [], $4) }

training :	TRAININGKEY ID
			LCB
			parameterListOpt								// Non capisco perché a volte va in conflitto e a volte no (vedi network)
			RCB					{ ($2, $4) }

validation :
	|							{ None }	
	|	VALIDATIONKEY
		LCB
		TESTSETKEY COLON ID									// IL TEST SET NON C'è SEMPRE, è UN PARAMETRO COME GLI ALTRI -> DA TOLGIERE
		parameterListOpt
		RCB						{ Some ($5, $6) }