%{
open System
open AST
%}

// Simboli terminali
%token <string> ID
%token <string> ATTID
%token <string> PATH
%token <double> NUMBER
%token LOAD
%token PLUS MINUS TIMES FRAC POW NEG
%token AND OR NOT TRUE FALSE
%token LT LTE GT GTE EQ NOTEQ
%token SIN COS TAN ATAN LOG LN FLOOR CEIL SQRT
%token MEAN SD MIN MAX SUM SUMSQUARED
%token LP RP LCB RCB LB RB COMMA NEWLINE COLON DOTS
%token EOF

// Associatività operatori e priorità (priorità minore prima)

// Forse bisogna mettere anche le parentesi
%nonassoc ID ATTID
%left prec_negate						// DA RIVEDERE -----------------
%left AND
%left OR
%nonassoc LT LTE GT GTE EQ NOTEQ			// Questi operatori si compaiono più di una volta si ha errore "1 > 2 > 3 -> Errore"
%left PLUS MINUS
%left TIMES FRAC 
%right POW								// POW è left?
%nonassoc NOT NEG
%nonassoc LP

// Scopo della grammatica
%start start

// Tipo di uscita in caso di parsing corretto
%type <AST.Network> start

%%

// Produzioni

start:	directives
		preprocessing
		network
		training
		validation
		EOF				{
							{
								Directives = $1;
								Preprocessing = $2;
								NetworkDefinition = $3;
								Training = $4;
								Validation = $5;
							}
						}

parameter :
	| ID COLON parameterValue		{ Parameter ($1, $3) }

parameterValue :
	| attributeList					{ $1 }
	| numberList					{ $1 }
	| expression					{ $1 }

attributeList :
	| LB attributeInnerList RB						{ $2 }

attributeInnerList :
	| attributeElement								{ [$1] }
	| attributeInnerList COMMA attributeElement		{ $3 :: $1 }

attributeElement :
	| ATTID DOTS ATTID					{ $1, $3 }	
	| ID								{ $1 }
	| ATTID								{ $1 }

numberList :
	| LB numberInnerList RB						{ $2 }

numberInnerList :
	| numberElement								{ [$1] }
	| numberInnerList COMMA numberElement		{ $3 :: $1 }

numberElement :
	| NUMBER DOTS NUMBER				{ $1, $3 }	
	| NUMBER							{ $1 }

directives :
	|									{ [] }
	| parameter							{ [$1] }
	| directives NEWLINE parameter		{ $3 :: $1 }


// Mettendo l'associatività e la priorità sopra posso definire la grammatica delle espressioni in modo molto più compatto
expression :
	| expression AND expression			{ And ($1, $3) }
	| expression OR expression			{ Or ($1, $3) }
	| expression LT expression			{ Rel ($1, $2, $3) }
	| expression LTE expression			{ Rel ($1, $2, $3) }
	| expression GT expression			{ Rel ($1, $2, $3) }
	| expression GTE expression			{ Rel ($1, $2, $3) }
	| expression EQ expression			{ Rel ($1, $2, $3) }
	| expression NOTEQ expression		{ Rel ($1, $2, $3) }
	| expression PLUS expression		{ Add ($1, $3) }
	| expression MINUS expression		{ Sub ($1, $3) }
	| expression TIMES expression		{ Prod ($1, $3) }
	| expression FRAC expression		{ Frac ($1, $3) }
	| expression POW expression			{ Pow ($1, $3) }
	| NOT expression					{ Not $2 }
	| MINUS LP expression RP			{ Neg $3 }
	| SIN LP expression RP				{ Sin $3 }
	| COS LP expression RP				{ Cos $3 }
	| TAN LP expression RP				{ Tan $3 }
	| ATAN LP expression RP				{ Atan $3 }
	| LOG LP expression RP				{ Log $3 }
	| LN LP expression RP				{ Ln $3 }
	| FLOOR LP expression RP			{ Floor $3 }
	| CEIL LP expression RP				{ Ceil $3 }
	| SQRT LP expression RP				{ Sqrt $3 }
	| LP expression RP					{ $2 }
	| MEAN LP statElement RP			{ Mean $3 }
	| SD LP statElement RP				{ Sd $3 }
	| MIN LP statElement RP				{ Min $3 }
	| MAX LP statElement RP				{ Max $3 }
	| SUM LP statElement RP				{ Sum $3 }
	| SUMSQUARED LP statElement RP		{ Sumsquared $3 }
	| ID								{ Id $1 }
	| ATTID								{ AttId $1 }
	| TRUE								{ True }
	| FALSE								{ False }
	| number							{ Num $1 }

number:
    | NUMBER                           { Convert.ToDouble($1) }
    | MINUS NUMBER %prec prec_negate   { Convert.ToDouble(-$2) }

statElement :
	| ID							{ Id $1 }
	| ATTID							{ AttId $1 }









preprocessing : ID	{}

network : ID	{}

training : ID	{}

validation : ID {}