%{
open System
open AST

let cultureInfo = System.Globalization.CultureInfo.CreateSpecificCulture("en-us")

// Per errori vedi reportParseErrorAt nella grammatica di F#


%}

// Simboli terminali
%token <string> ID
%token <string> ATTID
%token <string> INSTID			
%token <string> PATH
%token <double> NUMBER
%token PLUS MINUS TIMES FRAC POW
%token AND OR NOT TRUE FALSE
%token LT LTE GT GTE EQ NOTEQ
%token SIN COS TAN ATAN LOG LN FLOOR CEIL SQRT
%token MEAN SD MIN MAX SUM SUMSQUARED
%token LP RP LCB RCB LB RB COMMA NEWLINE COLON DOTS SEMICOLON
%token PREPROC TRAININGKEY VALIDATIONKEY PLOT ATTKEY INSTKEY TRAINSETKEY PLOTKEY TESTSETKEY
%token EOF

// Associatività operatori e priorità (priorità minore prima)

// Forse bisogna mettere anche le parentesi
%left AND OR
%left LT LTE GT GTE EQ NOTEQ			// NONASSOC -  Questi operatori se compaiono più di una volta si ha errore "1 > 2 > 3 -> Errore"
%left PLUS MINUS
%left TIMES FRAC 
%left UMINUS							// Non esiste veramente, serve solo per la precedenza
%right POW
%nonassoc NOT

// Scopo della grammatica
%start start

// Tipo di uscita in caso di parsing corretto
%type <AST.Network> start

%%

// Produzioni

start:	directives
		preprocessing
		network
		training
		validation
		EOF				{ { Directives = $1; Preprocessing = $2; NetworkDefinition = $3; Training = $4; Validation = $5;} }

parameter : ID COLON parameterValue		{ Parameter ($1, $3) }

parameterValue :
	| attributeList					{ AttList (true, $1) }
	| NOT attributeList				{ AttList (false, $2) }
	| numberList					{ NumList (true, $1) }
	| NOT numberList				{ NumList (false, $2) }
	| instList						{ InstList (true, $1) }
	| NOT instList					{ InstList (false, $2) }
	| expression					{ Exp $1 }

attributeList : LB attributeInnerList RB						{ $2 }

attributeInnerList :
	| attributeElement								{ [$1] }
	| attributeElement COMMA attributeInnerList		{ $1 :: $3 }

attributeElement :
	| ATTID DOTS ATTID					{ AttributeSequence (Convert.ToInt32($1, cultureInfo), Convert.ToInt32($3, cultureInfo)) }	
	| ID								{ Id $1 }
	| ATTID								{ AttId (Convert.ToInt32($1, cultureInfo)) }

numberList :
	| LB numberInnerList RB						{ $2 }
	
numberInnerList :
	| numberElement								{ [$1] }
	| numberElement COMMA numberInnerList 		{ $1 :: $3 }

numberElement :
	| number DOTS number				{ NumberSequence (Convert.ToDouble($1, cultureInfo), Convert.ToDouble($3, cultureInfo)) }	
	| number							{ Num (Convert.ToDouble($1, cultureInfo)) }

instList :
	| LB instInnerList RB				{ $2 }
	
instInnerList :
	| instElement						{ [$1] }
	| instElement COMMA instInnerList 	{ $1 :: $3 }

instElement :
	| INSTID DOTS INSTID					{ InstanceSequence (Convert.ToInt32($1, cultureInfo), Convert.ToInt32($3, cultureInfo)) }	
	| INSTID								{ InstId (Convert.ToInt32($1, cultureInfo)) }

directives :
	|									{ [] }
	| parameterList						{ $1 }

// Mettendo l'associatività e la priorità sopra posso definire la grammatica delle espressioni in modo molto più compatto
expression :
	| NOT expression					{ Not $2 }
	| MINUS LP expression RP 			{ Neg $3 }			// Forse non serve
	| expression POW expression			{ Pow ($1, $3) }
	| expression TIMES expression		{ Prod ($1, $3) }
	| expression FRAC expression		{ Frac ($1, $3) }
	| expression PLUS expression		{ Add ($1, $3) }
	| expression MINUS expression		{ Sub ($1, $3) }
	| expression LT expression			{ Rel ($1, Lt, $3) }
	| expression LTE expression			{ Rel ($1, Lte, $3) }
	| expression GT expression			{ Rel ($1, Gt, $3) }
	| expression GTE expression			{ Rel ($1, Gte, $3) }
	| expression EQ expression			{ Rel ($1, Eq, $3) }
	| expression NOTEQ expression		{ Rel ($1, NotEq, $3) }
	| expression AND expression			{ And ($1, $3) }
	| expression OR expression			{ Or ($1, $3) }
	| SIN LP expression RP				{ Sin $3 }
	| COS LP expression RP				{ Cos $3 }
	| TAN LP expression RP				{ Tan $3 }
	| ATAN LP expression RP				{ Atan $3 }
	| LOG LP expression RP				{ Log $3 }
	| LN LP expression RP				{ Ln $3 }
	| FLOOR LP expression RP			{ Floor $3 }
	| CEIL LP expression RP				{ Ceil $3 }
	| SQRT LP expression RP				{ Sqrt $3 }
	| LP expression RP					{ $2 }
	| MEAN LP statElement RP			{ Mean $3 }
	| SD LP statElement RP				{ Sd $3 }
	| MIN LP statElement RP				{ Min $3 }
	| MAX LP statElement RP				{ Max $3 }
	| SUM LP statElement RP				{ Sum $3 }
	| SUMSQUARED LP statElement RP		{ SumSquared $3 }
	| ID								{ ExpId $1 }											// Per il preprocessing, controllo che esista un'attributo con quel nome o lo faccio fare alla datatable
	| ATTID								{ ExpAttId (Convert.ToInt32($1, cultureInfo)) }			// Per il preprocessing, controllo che esista un'attributo con quell'indice e lo trasformo nel relativo nome			
	| TRUE								{ True }
	| FALSE								{ False }
	| number							{ ExpNum $1 }

number:
    | NUMBER                           { Convert.ToDouble($1, cultureInfo) }
    | MINUS NUMBER %prec UMINUS		   { Convert.ToDouble(-$2, cultureInfo) }		// La precedenza di questa REGOLA è pari alla precedenza di UMINUS

statElement :														
	| ID							{ $1 }
	| ATTID							{ $1 }

parameterList :
	| parameter							{ [$1] }
	| parameter COMMA parameterList		{ $1 :: $3 }

parameterListOpt :
	|					{ [] }
	| parameterList		{ $1 }

filter : 
	| ID LP parameterList RP		{ Filter ($1, $3) }
	| ID LP RP						{ Filter ($1, []) }

filterList :
	|								{ [] } 
	| filter						{ [$1] }
	| filter COMMA filterList		{ $1 :: $3 }

attributeFilters : ATTKEY LCB filterList RCB	{ $3 }
instanceFilters : INSTKEY LCB filterList RCB	{ $3 }

preprocessing : PREPROC
				LCB
				TRAINSETKEY COLON ID
				attributeFilters								// filtri per gli attributi SEMPRE prima di quelli per le istanze
				instanceFilters
				RCB					{ ($5, $6, $7) }

aspect : ID					
		 LCB
		 parameterList
		 RCB						{ Aspect ($1, $3) }

aspectList :
	| aspect					{ [$1] }					// Se qui metto la lista vuota ho un errore reduce/reduce  (DA RIVEDERE)
	| aspect aspectList			{ $1 :: $2 }

aspectListOpt :
	|				{ [] }
	| aspectList	{ $1 }

plot :
	|			{ false }
	| PLOTKEY	{ true }

network : 
	|	ID plot							// Con il plot opzionale vuol dire che qui la stringa si può accorciare? E' un problema??
		LCB
		parameterList					// Qui non posso usare parameterListOpt (DA RIVEDERE)
		aspectListOpt
		RCB 				{ ($1, $2, $4, $5) }
	|	ID plot							
		LCB					
		aspectListOpt
		RCB 				{ ($1, $2, [], $4) }

training :	TRAININGKEY ID
			LCB
			parameterListOpt								// Non capisco perché a volte va in conflitto e a volte no (vedi network)
			RCB					{ ($2, $4) }

validation :
	|							{ None }	
	|	VALIDATIONKEY
		LCB
		TESTSETKEY COLON ID									// IL TEST SET NON C'è SEMPRE, è UN PARAMETRO COME GLI ALTRI -> DA TOLGIERE
		parameterListOpt
		RCB						{ Some ($5, $6) }