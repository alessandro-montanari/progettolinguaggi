%{
open System
open AST
%}

// Simboli terminali
%token <string> ID
%token <string> ATTID
%token <string> PATH
%token <double> NUMBER
%token PLUS MINUS TIMES FRAC POW NEG
%token AND OR NOT TRUE FALSE
%token LT LTE GT GTE EQ NOTEQ
%token SIN COS TAN ATAN LOG LN FLOOR CEIL SQRT
%token MEAN SD MIN MAX SUM SUMSQUARED
%token LP RP LCB RCB LB RB COMMA NEWLINE COLON DOTS
%token PREPROC TRAINING VALIDATION
%token EOF

// Associatività operatori e priorità (priorità minore prima)

// Forse bisogna mettere anche le parentesi
%left AND OR
%left LT LTE GT GTE EQ NOTEQ			// NONASSOC -  Questi operatori se compaiono più di una volta si ha errore "1 > 2 > 3 -> Errore"
%left PLUS MINUS
%left TIMES FRAC 
%left UMINUS							// Non esiste veramente, serve solo per la precedenza
%right POW								// POW è left?
%nonassoc NOT NEG		

// Scopo della grammatica
%start start

// Tipo di uscita in caso di parsing corretto
%type <AST.Network> start

%%

// Produzioni

start:	directives
		preprocessing
		network
		training
		validation
		EOF				{
							{
								Directives = $1;
								Preprocessing = $2;
								NetworkDefinition = $3;
								Training = $4;
								Validation = $5;
							}
						}

parameter : ID COLON parameterValue		{ Parameter ($1, $3) }

parameterValue :
	| attributeList					{ AttList $1 }
	| numberList					{ NumList $1 }
	| expression					{ Val $1 }

attributeList : LB attributeInnerList RB						{ $2 }

attributeInnerList :
	| attributeElement								{ [$1] }
	| attributeInnerList COMMA attributeElement		{ $3 :: $1 }

attributeElement :
	| ATTID DOTS ATTID					{ AttributeListElement.Seq ($1, $3) }	
	| ID								{ AttributeListElement.Id $1 }
	| ATTID								{ AttributeListElement.AttId $1 }

numberList :
	| LB numberInnerList RB						{ $2 }
	
numberInnerList :
	| numberElement								{ [$1] }
	| numberInnerList COMMA numberElement		{ $3 :: $1 }

numberElement :
	| number DOTS number				{ NumberListElement.Seq ($1, $3) }	
	| number							{ NumberListElement.Num $1 }

directives :
	|									{ [] }
	| parameter							{ [$1] }
	| parameter NEWLINE directives		{ $1 @ [$3] }


// Mettendo l'associatività e la priorità sopra posso definire la grammatica delle espressioni in modo molto più compatto
expression :
	| expression LT expression			{ Rel ($1, Lt, $3) }
	| expression LTE expression			{ Rel ($1, Lte, $3) }
	| expression GT expression			{ Rel ($1, Gt, $3) }
	| expression GTE expression			{ Rel ($1, Gte, $3) }
	| expression EQ expression			{ Rel ($1, Eq, $3) }
	| expression NOTEQ expression		{ Rel ($1, NotEq, $3) }
	| expression AND expression			{ And ($1, $3) }
	| expression OR expression			{ Or ($1, $3) }
	| expression PLUS expression		{ Add ($1, $3) }
	| expression MINUS expression		{ Sub ($1, $3) }
	| expression TIMES expression		{ Prod ($1, $3) }
	| expression FRAC expression		{ Frac ($1, $3) }
	| expression POW expression			{ Pow ($1, $3) }
	| NOT expression					{ Not $2 }
	| MINUS LP expression RP 			{ Neg $3 }
	| SIN LP expression RP				{ Sin $3 }
	| COS LP expression RP				{ Cos $3 }
	| TAN LP expression RP				{ Tan $3 }
	| ATAN LP expression RP				{ Atan $3 }
	| LOG LP expression RP				{ Log $3 }
	| LN LP expression RP				{ Ln $3 }
	| FLOOR LP expression RP			{ Floor $3 }
	| CEIL LP expression RP				{ Ceil $3 }
	| SQRT LP expression RP				{ Sqrt $3 }
	| LP expression RP					{ $2 }
	| MEAN LP statElement RP			{ Mean $3 }
	| SD LP statElement RP				{ Sd $3 }
	| MIN LP statElement RP				{ Min $3 }
	| MAX LP statElement RP				{ Max $3 }
	| SUM LP statElement RP				{ Sum $3 }
	| SUMSQUARED LP statElement RP		{ Sumsquared $3 }
	| ID								{ Id $1 }
	| ATTID								{ AttId $1 }
	| TRUE								{ True }
	| FALSE								{ False }
	| number							{ Num $1 }

number:
    | NUMBER                           { Convert.ToDouble($1) }
    | MINUS NUMBER %prec UMINUS		   { Convert.ToDouble(-$2) }		// La precedenza di questa REGOLA è pari alla precedenza di UMINUS

statElement :
	| ID							{ Id $1 }
	| ATTID							{ AttId $1 }









preprocessing : PREPROC	{}

network : ID	{}

training : TRAINING ID	{}

validation : VALIDATION {}