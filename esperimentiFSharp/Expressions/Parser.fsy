%{

open Ast

%}

// The start token becomes a parser function in the compiled code:
%start start

// These are the terminal tokens of the grammar along with the types of
// the data carried by each token:
%token <System.Int32> INT32
%token <System.Double> DOUBLE
%token <string> FUNCTION
%token <string> AGGFUNCTION
%token <string> ID
%token PLUS MINUS ASTER	SLASH POW
%token LPAREN RPAREN LB RB COMMA DOTS
%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < Ast.Equation > start

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  In this case the actions 
// produce data using F# data construction terms.
start: Prog { Equation($1) }

Prog:
    | Expr EOF					{ $1 }
	
Expr: 
    | Expr PLUS  Term			{ Plus($1, $3)  }
    | Expr MINUS Term			{ Minus($1, $3) }
	| Expr POW Term				{ Pow($1, $3) }
    | Term						{ $1      }

Term:
    | Term ASTER Factor			{ Times($1, $3)  }
    | Term SLASH Factor			{ Divide($1, $3) }
    | Unary						{ $1 }

Unary:
    | Factor { $1 }
    | MINUS Factor { Negative($2) }
    
Factor:
    | DOUBLE								{ Value(Float($1))  }
    | INT32									{ Value(Integer($1)) }
	| ID									{ Value(Id($1)) }
    | LPAREN Expr RPAREN					{ $2 }
	| FUNCTION LPAREN Expr RPAREN			{ Value(Function($1, $3)) }
	| AGGFUNCTION LPAREN ExprList RPAREN	{ Value(AggregateFunction($1, $3)) }
	| DOUBLE DOTS DOUBLE					{ Value(Range($1, $3)) }

ExprList:
	| LB ExprListInner RB		{ $2 }

ExprListInner:
	| Expr						{ [$1] }
	| Expr COMMA ExprListInner 	{ $1 :: $3 }
